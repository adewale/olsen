package query

import (
	"testing"
)

// TestCameraFacetWithMultiWordMake tests that camera facets work correctly
// when camera_make contains multiple words (e.g., "Leica Camera AG")
//
// BUG REPRODUCTION:
// Database contains: camera_make="Leica Camera AG", camera_model="LEICA M11 Monochrom"
// Facet shows: "Leica Camera AG LEICA M11 Monochrom" (205 photos)
// User clicks facet
// URL generated: camera_make=Leica&camera_model=Camera+AG+LEICA+M11+Monochrom
// Query returns: 0 photos (WRONG!)
//
// Root cause: strings.SplitN(value, " ", 2) splits on FIRST space only
// Expected: Split on the boundary between make and model
// Actual: Splits "Leica Camera AG LEICA M11 Monochrom" into:
//   - make: "Leica" (WRONG - should be "Leica Camera AG")
//   - model: "Camera AG LEICA M11 Monochrom" (WRONG - should be "LEICA M11 Monochrom")

func TestCameraFacetWithMultiWordMake(t *testing.T) {
	// Create test database with photos
	db := setupTestDBWithSchema(t)
	defer db.Close()

	// Insert test photos with multi-word camera makes
	insertCameraPhotos(t, db, []struct {
		CameraMake  string
		CameraModel string
	}{
		{"Leica Camera AG", "LEICA M11 Monochrom"},
		{"Leica Camera AG", "LEICA M11 Monochrom"},
		{"Leica Camera AG", "LEICA M11 Monochrom"},
		{"Canon", "EOS R5"},
		{"Sony", "Alpha 7R V"},
		{"Hasselblad AB", "X2D 100C"}, // Another multi-word make
	})

	engine := NewEngine(db)

	// STEP 1: Compute facets with no filters
	facets, err := engine.ComputeFacets(QueryParams{Limit: 100})
	if err != nil {
		t.Fatalf("ComputeFacets failed: %v", err)
	}

	// Find Leica Camera AG facet
	var leicaFacet *FacetValue
	for i := range facets.Camera.Values {
		if facets.Camera.Values[i].Label == "Leica Camera AG LEICA M11 Monochrom" {
			leicaFacet = &facets.Camera.Values[i]
			break
		}
	}

	if leicaFacet == nil {
		t.Fatal("Expected to find 'Leica Camera AG LEICA M11 Monochrom' in camera facet")
	}

	t.Logf("Facet found: %s (count=%d)", leicaFacet.Label, leicaFacet.Count)

	if leicaFacet.Count != 3 {
		t.Errorf("Expected count=3, got count=%d", leicaFacet.Count)
	}

	// STEP 2: Parse the URL generated by the facet
	mapper := NewURLMapper()
	params := parseTestURL(t, mapper, leicaFacet.URL)

	t.Logf("Parsed params from URL '%s':", leicaFacet.URL)
	t.Logf("  CameraMake: %v", params.CameraMake)
	t.Logf("  CameraModel: %v", params.CameraModel)

	// CRITICAL BUG CHECK: The parsed params should match the database values
	if len(params.CameraMake) != 1 || params.CameraMake[0] != "Leica Camera AG" {
		t.Errorf("❌ BUG: CameraMake should be ['Leica Camera AG'], got %v", params.CameraMake)
		t.Errorf("  This is the root cause of the 0 results bug!")
	}

	if len(params.CameraModel) != 1 || params.CameraModel[0] != "LEICA M11 Monochrom" {
		t.Errorf("❌ BUG: CameraModel should be ['LEICA M11 Monochrom'], got %v", params.CameraModel)
		t.Errorf("  This is the root cause of the 0 results bug!")
	}

	// STEP 3: Execute query with the parsed params
	result, err := engine.Query(params)
	if err != nil {
		t.Fatalf("Query failed: %v", err)
	}

	t.Logf("Query with parsed params returned %d photos", result.Total)

	// THE CRITICAL TEST: The query result should match the facet count
	if result.Total != leicaFacet.Count {
		t.Errorf("❌ CRITICAL BUG: Facet shows count=%d but query returns %d photos",
			leicaFacet.Count, result.Total)
		t.Errorf("  User sees '%s (%d)' in facet", leicaFacet.Label, leicaFacet.Count)
		t.Errorf("  User clicks facet")
		t.Errorf("  URL: %s", leicaFacet.URL)
		t.Errorf("  Query returns %d photos (WRONG!)", result.Total)
		t.Errorf("")
		t.Errorf("  Root cause: buildCameraURLs() uses strings.SplitN(value, \" \", 2)")
		t.Errorf("  which splits on the FIRST space, not the boundary between make and model")
	} else {
		t.Logf("✅ CORRECT: Facet count (%d) matches query result (%d)", leicaFacet.Count, result.Total)
	}
}

func TestCameraFacetWithSingleWordMake(t *testing.T) {
	// This test verifies that single-word makes still work (regression test)
	db := setupTestDBWithSchema(t)
	defer db.Close()

	// Insert photos with single-word makes
	insertCameraPhotos(t, db, []struct {
		CameraMake  string
		CameraModel string
	}{
		{"Canon", "EOS R5"},
		{"Canon", "EOS R5"},
		{"Sony", "Alpha 7R V"},
	})

	engine := NewEngine(db)

	// Compute facets
	facets, err := engine.ComputeFacets(QueryParams{Limit: 100})
	if err != nil {
		t.Fatalf("ComputeFacets failed: %v", err)
	}

	// Find Canon facet
	var canonFacet *FacetValue
	for i := range facets.Camera.Values {
		if facets.Camera.Values[i].Label == "Canon EOS R5" {
			canonFacet = &facets.Camera.Values[i]
			break
		}
	}

	if canonFacet == nil {
		t.Fatal("Expected to find 'Canon EOS R5' in camera facet")
	}

	// Parse URL and execute query
	mapper := NewURLMapper()
	params := parseTestURL(t, mapper, canonFacet.URL)

	result, err := engine.Query(params)
	if err != nil {
		t.Fatalf("Query failed: %v", err)
	}

	// Single-word makes should work correctly
	if result.Total != canonFacet.Count {
		t.Errorf("Single-word make broken: facet shows %d but query returns %d",
			canonFacet.Count, result.Total)
	}
}

func TestCameraFacetAllRealWorldCases(t *testing.T) {
	// Test with various real-world camera name patterns
	db := setupTestDBWithSchema(t)
	defer db.Close()

	// Real-world camera names with various patterns
	insertCameraPhotos(t, db, []struct {
		CameraMake  string
		CameraModel string
	}{
		{"Leica Camera AG", "LEICA M11 Monochrom"},                   // Multi-word make, multi-word model
		{"Leica Camera AG", "LEICA Q2"},                              // Multi-word make, short model
		{"Hasselblad AB", "X2D 100C"},                                // Multi-word make
		{"Phase One A/S", "IQ4 150MP"},                               // Multi-word make with slash
		{"Canon", "EOS R5"},                                          // Single-word make
		{"Sony", "Alpha 7R V"},                                       // Single-word make
		{"Apple", "iPhone 15 Pro Max"},                               // Single-word make, multi-word model
		{"Fujifilm Corporation", "X-T5"},                             // Multi-word make
		{"Nikon Corporation", "Z 9"},                                 // Multi-word make
		{"OM Digital Solutions", "OM-1"},                             // Multi-word make with "Digital"
		{"DJI", "Mavic 3 Pro Cine"},                                  // Single-word make, long model
		{"GoPro", "HERO11 Black"},                                    // Single-word make
		{"Sigma Corporation", "fp L"},                                // Multi-word make
		{"RED Digital Cinema", "V-RAPTOR 8K"},                        // Multi-word make with "Digital"
		{"ARRI", "ALEXA Mini LF"},                                    // Single-word make
		{"Blackmagic Design Pty Ltd", "Pocket Cinema Camera 6K Pro"}, // Very long make
	})

	engine := NewEngine(db)
	mapper := NewURLMapper()

	// Compute facets
	facets, err := engine.ComputeFacets(QueryParams{Limit: 100})
	if err != nil {
		t.Fatalf("ComputeFacets failed: %v", err)
	}

	// Test each camera facet
	failedCameras := []string{}
	for _, facetValue := range facets.Camera.Values {
		params := parseTestURL(t, mapper, facetValue.URL)

		// Execute query
		result, err := engine.Query(params)
		if err != nil {
			t.Errorf("Query failed for '%s': %v", facetValue.Label, err)
			continue
		}

		// Check if count matches
		if result.Total != facetValue.Count {
			failedCameras = append(failedCameras, facetValue.Label)
			t.Errorf("❌ '%s': facet shows %d but query returns %d",
				facetValue.Label, facetValue.Count, result.Total)
			t.Logf("  URL: %s", facetValue.URL)
			t.Logf("  Parsed make: %v", params.CameraMake)
			t.Logf("  Parsed model: %v", params.CameraModel)
		}
	}

	if len(failedCameras) > 0 {
		t.Errorf("\n\n❌ FAILED FOR %d CAMERAS:", len(failedCameras))
		for _, camera := range failedCameras {
			t.Errorf("  - %s", camera)
		}
		t.Errorf("\nThe bug affects ALL cameras with multi-word makes!")
	}
}
